-- MASTER RESET SCRIPT (COMPLETE)
-- Run this to RESTORE EVERYTHING (Reviews, Watchlist, Lists, Permissions).

-- 1. DROP EVERYTHING (Clean Slate)
drop table if exists list_items cascade;
drop table if exists lists cascade;
drop table if exists movie_lists cascade; -- Dropping old version if exists
drop table if exists reviews cascade;
drop table if exists watchlist cascade;
drop table if exists user_tastes cascade;

-- 2. ENABLE EXTENSIONS
create extension if not exists vector;

-- 3. CREATE TABLES

-- A. Reviews Table
create table reviews (
  id uuid default gen_random_uuid() primary key,
  user_id text not null,
  movie_id integer not null,
  rating integer check (rating >= 1 and rating <= 5),
  content text,
  embedding vector(384),
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, movie_id)
);

-- B. Watchlist Table
create table watchlist (
  user_id text not null,
  movie_id integer not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  primary key (user_id, movie_id)
);

-- C. Lists Table (New System)
create table lists (
  id bigint generated by default as identity primary key,
  user_id text not null,
  name text not null,
  description text,
  is_public boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- D. List Items Table (Movies inside lists)
create table list_items (
  id bigint generated by default as identity primary key,
  list_id bigint references lists(id) on delete cascade not null,
  movie_id integer not null,
  added_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(list_id, movie_id)
);

-- E. User Tastes Table (For AI Recommendations)
create table user_tastes (
  user_id text primary key,
  taste_vector vector(384),
  rating_count integer default 0,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- 4. ENABLE RLS (Required)
alter table reviews enable row level security;
alter table watchlist enable row level security;
alter table lists enable row level security;
alter table list_items enable row level security;
alter table user_tastes enable row level security;

-- 5. APPLY PERMISSIVE POLICIES (Fixes "Failed to create" errors)

-- Reviews
create policy "Allow all reviews" on reviews for all using (true) with check (true);

-- Watchlist
create policy "Allow all watchlist" on watchlist for all using (true) with check (true);

-- Lists
create policy "Allow all lists" on lists for all using (true) with check (true);

-- List Items
create policy "Allow all list items" on list_items for all using (true) with check (true);

-- User Tastes
create policy "Allow all tastes" on user_tastes for all using (true) with check (true);
-- Create a function to search for reviews similar to a query embedding
create or replace function match_reviews (
  query_embedding vector(384),
  match_threshold float,
  match_count int
)
returns table (
  id uuid,
  content text,
  movie_id integer,
  similarity float
)
language plpgsql
as $$
begin
  return query
  select
    reviews.id,
    reviews.content,
    reviews.movie_id,
    1 - (reviews.embedding <=> query_embedding) as similarity
  from reviews
  where 1 - (reviews.embedding <=> query_embedding) > match_threshold
  order by similarity desc
  limit match_count;
end;
$$;

-- Create a function for Proactive RAG (matching based on user taste vector)
create or replace function match_movie_recommendations (
  query_embedding vector(384),
  match_threshold float,
  match_count int,
  excluded_ids integer[]
)
returns table (
  movie_id integer,
  similarity float
)
language plpgsql
as $$
begin
  return query
  select
    distinct on (reviews.movie_id) reviews.movie_id,
    1 - (reviews.embedding <=> query_embedding) as similarity
  from reviews
  where reviews.embedding is not null 
    and 1 - (reviews.embedding <=> query_embedding) > match_threshold
    and not (reviews.movie_id = any(excluded_ids))
  order by reviews.movie_id, similarity desc
  limit match_count;
end;
$$;
